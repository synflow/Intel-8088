/*
 * Copyright (c) 2015 Matthieu
 * All rights reserved.
 */
package intel_8088.eu;

task InstrDecode {
	import intel_8088.Consts_8086.*;

	in sync ready u8 instr, sync u16 bus_data_in;

	sync {
		out u3 src, u3 dest;
	}
	out opcode_t opcode;
	sync {
		out u16 bus_addr, bus_data;
		out u2 qs;
		out u8 instr_mem;
	}

	const u2 /*NORMAL = 0,*/ FIRST_BYTE = 1, NEXT_BYTE = 3, EMPTIED = 2;

	void loop() {
		u8 instr_b0 = instr.read();
		print("got instruction byte ", instr_b0);
		qs.write(FIRST_BYTE);
		if (instr_b0 >> 2 == 0) { // ADD
			const bool d = instr_b0[1]/*, w = instr_b0[0]*/;
			u8 instr_b1 = instr.read();
			qs.write(NEXT_BYTE);
			u2 mod = instr_b1 >> 6;
			u3 reg = (instr_b1 >> 3) & 7;
			u3 r_m = instr_b1 & 7;

			if (mod == 0b11) {
				src.write(reg);
				src.write(r_m);
				dest.write(d ? reg : r_m);
				opcode.write(OPCODE_ADD);
			} else {
				instr_mem.write(instr_b1);
				fence;
				bus_data_in.read();
				opcode.write(OPCODE_ADD);
				// TODO: write data from bus to ALU
				if (d) {
					dest.write(reg);
				}
			}
		} else if (instr_b0 >> 3 == 0b01010) { // push
			u3 reg = (instr_b0 >> 3) & 7;
			//src1.write(REG_SP);
			// do SP += 2
			//src1.write(reg);
			bus_addr.write(50); // value of SP
			bus_data.write(reg); // value of data to push
		} else if (instr_b0 >> 2 == 0b100010) { // MOV register/memory to/from register
			const bool d = instr_b0[1], w = instr_b0[0]; 
			u8 instr_b1 = instr.read();
			qs.write(NEXT_BYTE);
			u2 mod = instr_b1 >> 6;
			u3 reg = (instr_b1 >> 3) & 7;
			u3 r_m = instr_b1 & 7;

			if (mod == 0b11) {
				src.write(d ? r_m : reg);
				dest.write(d ? reg : r_m);
				opcode.write(OPCODE_MOV);
			}
		} else if (instr_b0 >> 3 == 0b01000) { // INC register
			u3 reg = (u3) instr_b0;
			src.write(reg);
			dest.write(reg);
			opcode.write(OPCODE_INC);
		} else {
			// Jxx instructions
			idle(70);
			
			// when jump has been computed output
			qs.write(EMPTIED);
		}
	}
}
