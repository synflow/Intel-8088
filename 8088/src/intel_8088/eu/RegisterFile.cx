/*
 * Copyright (c) 2015 Matthieu
 * All rights reserved.
 */
package intel_8088.eu;

// split registers in two Register Files (RFs)
// based on EA calculation times, we can suppose that:
//   - BP and SI are in one RF
//   - BX and DI are in a second RF
//
// putting CX/DX in RF1 and AX/BX in RF2 because:
//   - bit pattern would minimize logic to route to one or the other: given reg, use e ^ g
//   - allows selection of 8-bit halves in same RF (CL/CH for CX, DL/DH for DX)
//     again should simplify logic 

/*
 * REG    W=0  W=1
 * ---    ---  ---
 * 000    AL   AX
 * 011    BL   BX
 * 100    AH   SP
 * 111    BH   DI
 */

/*
 * REG    W=0  W=1
 * ---    ---  ---
 * 001    CL   CX
 * 010    DL   DX
 * 101    CH   BP
 * 110    DH   SI
 */
 
network RegisterFile {

	sync {
		in u3 addr, u2 addr_half1, addr_half2;
	}
	in u3 dest, u16 data;
	out u16 result, res_half1, res_half2;

	rf1 = new HalfRF();
	rf2 = new HalfRF();

	mux_addr = new task {
		properties {type: "combinational"}
		out u2 rf1_addr, rf2_addr;
		void loop() {
			if (addr.available()) {
				u3 addr = addr.read();
				if (addr[1] ^ addr[0]) {
					rf2_addr.write(addr >> 1);
				} else {
					rf1_addr.write(addr >> 1);
				}
			}
		}
	};

	mux_src1 = new task {
		properties {type: "combinational"}
		void loop() {
			if (addr_half1.available()) {
				rf1.src.write(addr_half1.read());
			} else {
				rf1.src.write(mux_addr.rf1_addr.read());
			}
		}
	};

	mux_src2 = new task {
		properties {type: "combinational"}
		void loop() {
			if (addr_half2.available()) {
				rf2.src.write(addr_half2.read());
			} else {
				rf2.src.write(mux_addr.rf2_addr.read());
			}
		}
	};

	//rf1.reads(dest, data);
	//rf2.reads(dest, data);

	rf1.writes(result);

	this.reads(rf1.result, rf2.result);

}

task HalfRF {

	in u2 src/*, dest, sync u16 data*/;
	out u16 result;

	u16 registers[4];
	
	void loop() {
		result.write(registers[src.read()]);
//		if (data.available) {
//			registers[dest.read()] = data.read();
//		}
	}

}
